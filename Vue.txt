MVVM모델: model - view - viewModel
dom이란: 구조화된 문서를 표현하는 방법으로, 크로스 플랫폼
이고 랭귀지 독립

v-text: 태그 자체가 텍스트 형태로 렌더링 된다. 즉 
Vue({
 el: '#app',
 data: '<i>하하</i>'
})
부분에 선언한 태그들이 텍스트로 변환되어서 나타난다.
<i>하하</i> 이런식으로
v-html: html을 렌더링 하는 것. 그러면 위와는 다르게 html 태그가
인식되어서 출력되게 된다.
v-show: 보이기 / 안보이기 설정 가능. 이것도 if문과 동일하게 사용이 가능. 왜냐하면 어쨋든 값이 true, false 에 따라서 결정되니까.
v-if: if 조건문
v-else: else 조건문
v-else-if: else if 조건문
v-pre: 특정 엘리먼트를 무시하는데 사용.그 엘리먼트 내부의
자식 엘리먼트들을 신경쓰지 않고 그냥 건너뛴다. 컴파일 속도 향상됨
v-cloak: 자바스크립트 로드 중에 모든 vue.js 요소가 뜨는 것을 방지한다.
v-once: 컴포넌트를 초기에 딱 한번만 랜더링함. 자바스크립트에서 사용
하는 데이터를 사용하긴 하지만, 변동이 없고 한결같은 정적부분을
보여줄 때 사용. 업데이트 성능 최적화에 사용
v-bind: html 엘리먼트에서 vue 엘리먼트 데이터로 설정하고 싶을 때 사용
이건 생략도 가능하다 함. v-bind:src 가 아닌 :src만 해도 된다고 함
v-model: 양방향 데이터 바인딩. 페이지 내에서 vue인스턴스 내부 데이터에
변화를 주는 방법. 폼에 관련된 태그에만 사용될 수 있다.(<input>, <select>, <textarea>)
v-on: 

computed와 method의 차이점
1. computed는 종속된 값에 의해 결과값이 캐싱된다는 것. 즉 method에 선언된 함수는 호출된 1번만 실행이 되는 반면, computed는 매번 실행이 된다는 것이다.

watch: 이 속성은 어떠한 속성에 대한 이름이나 해당 속성이 변경되었을 때 호출할 함수들을 지정하는 것이다


*단방향 바인딩: 데이터 -> 뷰의 형태로 바인딩 되어 있어서, 데이터 값이 변하면 바로 바로 업데이트 됨
*양방향 바인딩: 데이터와 뷰 사이의 양방향으로 바인딩하여 데이터가 양방향으로 흐르게 해주는 것.
즉, 데이터에 있는 값이 뷰에 나타나고, 이 뷰의 값이 바뀌면 데이터 값도 바뀜.

computed 속성: 계산형 속성. 함수를 등록해두면 마치 속성처럼 이용할 수 있다. 그러니까 함수 등록이라고 생각하면 됨

@change는 @input과 비슷한 개념이지만 오류 처리가 좀 더 잘 되나봄.

*부모 자식간의 컴포넌트들 통신은 props와 events 를 사용하면 된다. 하지만 부모 자식관계가 아닐 경우에는 이벤트 버스 객체를 생성하여 통신한다.

*props를 이용한 정보 전달. props라는 옵션에 배열로 나열하면 됨.
props : ['message'] 이런식으로 작성하면 <template>에서 {{ message }} 이렇게 호출해서 사용하면 됨.

*배열객체의 기본값을 부여할 때는 return으로 보내주면 됨

*event를 이용한 정보전달
자식 컴포넌트에서 이벤트를 발신하고 부모 컴포넌트에서 v-on 디렉티브ㅡ를 이용해 이벤트를 수신함.

*event 객체를 이용한 정보전달